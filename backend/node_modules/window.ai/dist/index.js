// src/index.ts
function isMessagesInput(input) {
  return "messages" in input;
}
function isTextOutput(output) {
  return "text" in output;
}
function isMessageOutput(output) {
  return "message" in output;
}
var ErrorCode = /* @__PURE__ */ ((ErrorCode2) => {
  ErrorCode2["NotAuthenticated"] = "NOT_AUTHENTICATED";
  ErrorCode2["PermissionDenied"] = "PERMISSION_DENIED";
  ErrorCode2["RequestNotFound"] = "REQUEST_NOT_FOUND";
  ErrorCode2["InvalidRequest"] = "INVALID_REQUEST";
  ErrorCode2["ModelRejectedRequest"] = "MODEL_REJECTED_REQUEST";
  return ErrorCode2;
})(ErrorCode || {});
var EventType = /* @__PURE__ */ ((EventType2) => {
  EventType2["ModelChanged"] = "model_changed";
  EventType2["Error"] = "error";
  return EventType2;
})(EventType || {});
var VALID_DOMAIN = "https://windowai.io";
function hasWindowAI() {
  return typeof globalThis.window.ai?.getCompletion === "function";
}
var DEFAULT_WAIT_OPTIONS = {
  interval: 100,
  timeout: 2400
  // https://github.com/alexanderatallah/window.ai/pull/34#discussion_r1170545022
};
async function waitForWindowAI(opts = DEFAULT_WAIT_OPTIONS) {
  if (hasWindowAI()) {
    return;
  }
  await new Promise((resolve, reject) => {
    let counter = 0;
    const timerInterval = setInterval(() => {
      counter += opts.interval;
      if (counter > opts.timeout) {
        clearInterval(timerInterval);
        reject(new Error("window.ai not found"));
      }
      if (hasWindowAI()) {
        clearInterval(timerInterval);
        resolve(true);
      }
    }, opts.interval);
  });
}
var getWindowAI = async (opts = DEFAULT_WAIT_OPTIONS) => {
  await waitForWindowAI(opts);
  return globalThis.window.ai;
};
export {
  ErrorCode,
  EventType,
  VALID_DOMAIN,
  getWindowAI,
  hasWindowAI,
  isMessageOutput,
  isMessagesInput,
  isTextOutput,
  waitForWindowAI
};
//# sourceMappingURL=index.js.map